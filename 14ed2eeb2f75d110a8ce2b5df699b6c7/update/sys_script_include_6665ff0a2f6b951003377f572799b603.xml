<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_script_include">
    <sys_script_include action="INSERT_OR_UPDATE">
        <access>package_private</access>
        <active>true</active>
        <api_name>x_156954_sch_util.JobUtilsScheduledJob</api_name>
        <caller_access/>
        <client_callable>false</client_callable>
        <description/>
        <name>JobUtilsScheduledJob</name>
        <script><![CDATA[var JobUtilsScheduledJob = Class.create();
JobUtilsScheduledJob.prototype = {
	initialize: function (scheduledJobGr, table) {
		if (scheduledJobGr) {
			if (typeof scheduledJobGr === "string") {
				if (!table) {
					table = 'sysauto';
				}
				scheduledJobGr = this._getGlideRecordWithId(table, scheduledJobGr);
			}
			if (scheduledJobGr + "" === "[object GlideRecord]") {
				this.setFromGr(scheduledJobGr);
			} else if (scheduledJobGr + "" === "[object Object]") {
				this.setFromModel(scheduledJobGr);
			}
		}
	},

	setFromGr: function (scheduledJobGr) {
		//this.gr = scheduledJobGr;
		this.sysId = scheduledJobGr.getUniqueValue();
		this.jobName = scheduledJobGr.getValue("name");
		this.active = (scheduledJobGr.getValue("active") == "1");
		this.sysScope = this._getReferenceField("sys_scope", scheduledJobGr);
		this.sysClass = scheduledJobGr.getValue('sys_class_name');
		this.jobType = scheduledJobGr.getDisplayValue('sys_class_name');
		this.runType = this._getRunType(scheduledJobGr)
		this.nextExecution = this._getNextScheduledExecutionTime();
	},

	setFromModel: function (model) {
		
		for (var key in model) {
			this[key] = model[key];
		}
		//this.gr = this._getGlideRecordWithId(this.sysClass, scheduledJobGr);
	},

	getExecutions: function (count) {
		if (!this.sysId) {
			return;
		}

		var scheduleGr = this._getSchedules(count);
		if (!scheduleGr || !scheduleGr.hasNext()) {
			return;
		}
		var transactionCount = count;
		while (scheduleGr.next()) {
			var executionContext = this.addExecutionContext();
			if (scheduleGr.getValue('state') === '1') {
				executionContext.setJobInProgress(true, scheduleGr.getDisplayValue('state'));
			} else {
				executionContext.setJobInProgress(false, scheduleGr.getDisplayValue('state'));
			}
			var nextAction = new GlideDateTime(scheduleGr.getValue('next_action'));
			executionContext.setStartTime(nextAction);
			transactionCount--;
		}
		if (transactionCount <= 0) {
			return;
		}
		//Get past job executions
		//Unable to do from scoped application currently
		// var transactionLogGr = this._getTransactionHistory(transactionCount);
		// if (!transactionLogGr || !transactionLogGr.hasNext()) {
		// 	return;
		// }
		// while(transactionLogGr.next()){
		// 	var executionContext = this.addExecutionContext();
		// 	executionContext.setJobInProgress(false, 'Finished');
		// 	var startTime = new GlideDateTime(transactionLogGr.getValue('start_process_at'));
		// 	executionContext.setStartTime(startTime);
		// 	var processingTime = parseInt(transactionLogGr.getValue('transaction_processing_time') / 1000);
		// 	startTime.addSeconds(processingTime);
		// 	executionContext.addEndTime(startTime);
		// }

	},

	clearExecutions: function(){
		this.executionContexts = [];
	},

	addExecutionContext: function () {
		if (!this.executionContexts) {
			this.executionContexts = [];
		}
		this.executionContexts.push(new JobUtilsExecutionContext());
		return this.executionContexts[this.executionContexts.length - 1];
	},

	isInProgress: function () {
		if (!this.executionContexts || this.executionContexts.length < 1) {
			return false;
		}
		for (var i = 0; i < this.executionContexts.length; i++) {
			if (this.executionContexts[i].inProgress) {
				return true;
			}
		}
		return false;
	},

	//Internal Functions

	_getSchedules: function (count) {
		if (!this.sysId) {
			return;
		}
		var scheduleGr = new GlideRecord('sys_trigger');
		scheduleGr.addQuery('document_key', this.sysId);
		scheduleGr.orderBy('next_action');
		if (count) {
			scheduleGr.setLimit(count);
		} else {
			scheduleGr.setLimit(1);
		}
		scheduleGr.query();
		return scheduleGr;
	},

	_getJobSchedule: function () {
		var schedules = [];
		if (!this.sysId) {
			return schedules;
		}
		var scheduleGr = new GlideRecord('sys_trigger');
		scheduleGr.addQuery('document_key', this.sysId);
		scheduleGr.query();
		while (scheduleGr.next()) {
			var schedule = {};
			schedule.state = {
				display: scheduleGr.getDisplayValue('state'),
				value: scheduleGr.getValue('state')
			}
			var nextAction = new GlideDateTime(scheduleGr.getValue('next_action'));
			var gdt = new GlideDateTime();
			if (schedule.state.value === '1') {
				schedule.nextAction = GlideDateTime.subtract(nextAction, gdt).getDisplayValue();
			} else {
				schedule.nextAction = GlideDateTime.subtract(gdt, nextAction).getDisplayValue();
			}

			schedule.triggerType = {
				display: scheduleGr.getDisplayValue('trigger_type'),
				value: scheduleGr.getValue('trigger_type')
			}
			schedules.push(schedule);
		}
		return schedules;
	},

	_getReferenceField: function (columnName, scheduledJobGr) {
		var returnObj = {};
		if (columnName) {
			returnObj.id = scheduledJobGr.getValue(columnName);
			returnObj.displayValue = scheduledJobGr.getDisplayValue(columnName);
		}
		return returnObj;
	},

	_getGlideRecordWithId: function (table, id) {
		if(!gs.tableExists(table)){
			return;
		}
		var scheduledJobGr = new GlideRecord(table);
		if (scheduledJobGr.get(id)) {
			var jobTableName = scheduledJobGr.getValue('sys_class_name');
			if (jobTableName != table) {
				return this._getGlideRecordWithId(jobTableName, id);
			}
			return scheduledJobGr;
		}
	},

	_getNextScheduledExecutionTime: function () {
		var scheduleGr = this._getSchedules(1);
		if (!scheduleGr || !scheduleGr.hasNext()) {
			return '';
		}
		if (scheduleGr.next()) {
			var nextActionGdt = new GlideDateTime(scheduleGr.getValue('next_action'));
			var nextAction = {
				value: nextActionGdt.getNumericValue(),
				display: GlideDateTime.subtract(new GlideDateTime(), nextActionGdt).getDisplayValue()
			}
			return nextAction;
		}
	},

	_getTransactionHistory: function (count) {
		//I want to get transaction history for the scheduled jobs, but of course servicenow wont let scoped applications read this info.....
		// var transactionLogGr = new GlideRecord('syslog_transaction');
		// transactionLogGr.addQuery('type', 'scheduler');
		// transactionLogGr.addQuery('origin_scope', this.sysScope.id);
		// transactionLogGr.addQuery('url', 'JOB: ' + this.jobName);
		// transactionLogGr.orderByDesc('sys_created_on');
		// if (count) {
		// 	transactionLogGr.setLimit(count);
		// } else {
		// 	transactionLogGr.setLimit(1);
		// }
		// transactionLogGr.query();
		// return transactionLogGr;
	},

	_getRunType: function (scheduledJobGr) {
		var runType = scheduledJobGr.getValue('run_type');
		var runInfo = {
			type: runType,
			title: scheduledJobGr.getDisplayValue('run_type'),
			display: '',
		};

		var runTime = scheduledJobGr.getValue('run_time');
		var runTimeGT = new GlideTime();
		runTimeGT.setValue(runTime);


		if (runType === 'daily') {

			runInfo.display = 'at ' + runTimeGT.getDisplayValue();

		} else if (runType === 'periodically') {

			var runPeriod = scheduledJobGr.getValue('run_period');
			var duration = new GlideDuration();
			duration.setValue(runPeriod);
			runInfo.display = 'every ' + duration.getDisplayValue();

		} else if (runType === 'weekly') {

			var dayOfWeek = scheduledJobGr.getDisplayValue('run_dayofweek');
			runInfo.display = 'every ' + dayOfWeek + ' at ' + runTimeGT.getDisplayValue();

		} else if (runType === 'monthly') {
			var dayOfMonth = scheduledJobGr.getValue('run_dayofmonth');
			if (dayOfMonth) {
				dayOfMonth = parseInt(dayOfMonth);
				var nth = function (d) {
					if (d > 3 && d < 21) return 'th';
					switch (d % 10) {
						case 1: return "st";
						case 2: return "nd";
						case 3: return "rd";
						default: return "th";
					}
				}
				runInfo.display = 'on the ' + dayOfMonth + nth(dayOfMonth);
			}
		} else if (runType === 'once') {

			var runStart = scheduledJobGr.getValue('run_start');
			if(runStart){
				var runStartGdt = new GlideDateTime(runStart);
				runInfo.display = 'At ' + runStartGdt.getDisplayValue();
			}

		} else if (runType === 'parent') {
			var parentJob =  scheduledJobGr.getDisplayValue('parent');
			runInfo.display = '(' + parentJob + ')';
		} else if (runType === 'business_calendar_start') {

		} else if (runType === 'business_calendar_end') {

		}

		return runInfo;
	},

	type: 'JobUtilsScheduledJob'
};]]></script>
        <sys_class_name>sys_script_include</sys_class_name>
        <sys_created_by>erik.anderson</sys_created_by>
        <sys_created_on>2022-12-05 14:34:03</sys_created_on>
        <sys_id>6665ff0a2f6b951003377f572799b603</sys_id>
        <sys_name>JobUtilsScheduledJob</sys_name>
        <sys_package display_value="Scheduled Job Utilities" source="x_156954_sch_util">14ed2eeb2f75d110a8ce2b5df699b6c7</sys_package>
        <sys_policy/>
        <sys_scope display_value="Scheduled Job Utilities">14ed2eeb2f75d110a8ce2b5df699b6c7</sys_scope>
        <sys_update_name>sys_script_include_6665ff0a2f6b951003377f572799b603</sys_update_name>
    </sys_script_include>
</record_update>
